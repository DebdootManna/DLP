# Finite Automata String Validator

## Overview
This program implements a string validator using finite automata concepts. It reads the definition of a finite automaton and validates whether a given string is accepted by that automaton.

## Compilation
```bash
gcc -o fa_validator finite_automata_validator.c -Wall
```

## Execution
```bash
./fa_validator
```

## Input Format
The program accepts input in the following order:

1. **Number of input symbols**: Integer representing alphabet size
2. **Input symbols**: Space-separated characters
3. **Number of states**: Total states in the automaton
4. **Initial state**: Starting state number
5. **Number of accepting states**: Count of final/accepting states
6. **Accepting states**: Space-separated state numbers
7. **Transition table**: Each line in format: `from_state to symbol -> to_state`
8. **Input string**: String to validate

## Sample Input/Output

### Example 1: From the problem statement
```
Number of input symbols : 2
Input symbols : a b
Enter number of states : 4
Initial state : 1
Number of accepting states : 1
Accepting states : 2
Transition table :
1 to a -> 2
1 to b -> 3
2 to a -> 1
2 to b -> 4
3 to a -> 4
3 to b -> 1
4 to a -> 3
4 to b -> 2

Input string : abbabab
Valid string
```

## Algorithm Explanation

### Key Components

1. **Data Structure**: The `FiniteAutomata` struct stores:
   - States and symbols
   - Start state and accept states
   - Transition table (2D array indexed by state and symbol)

2. **Validation Process**:
   - Start at the initial state
   - For each character in the input string:
     - Find the symbol index
     - Look up the next state in the transition table
     - Move to the next state
   - After processing all characters, check if the current state is an accepting state

3. **Time Complexity**: O(n) where n is the length of the input string

4. **Space Complexity**: O(s × a) where s is the number of states and a is the alphabet size

## Test Cases

### Test Case 1: Binary strings with alternating pattern
**Automaton**: Accepts strings where 0s and 1s alternate
```
Number of input symbols : 2
Input symbols : 0 1
Enter number of states : 3
Initial state : 0
Number of accepting states : 2
Accepting states : 1 2
Transition table :
0 to 0 -> 1
0 to 1 -> 2
1 to 0 -> 3
1 to 1 -> 2
2 to 0 -> 1
2 to 1 -> 3
3 to 0 -> 3
3 to 1 -> 3

Input string : 01010
Valid string
```

### Test Case 2: Strings over {a,b,c} starting and ending with same letter
Design the automaton with states tracking the first character and validating the last character matches.

### Test Case 3: Strings starting with alphabets only
Use states to ensure the first character is alphabetic, then accept any alphanumeric characters.

## Implementation Details

### Key Functions

| Function | Description | Time Complexity |
|----------|-------------|-----------------|
| `getSymbolIndex()` | Finds index of a symbol in the alphabet | O(a) where a = alphabet size |
| `isAcceptState()` | Checks if a state is accepting | O(f) where f = number of final states |
| `validateString()` | Main validation logic | O(n) where n = string length |

### Edge Cases Handled
- Invalid characters (not in alphabet)
- Missing transitions (undefined state transitions)
- Empty strings
- Very long strings (up to 1000 characters)

## Design Decisions

1. **Transition Table Representation**: Used a 2D array for O(1) lookup time during validation
2. **State Numbering**: Allows any integer state numbers (not restricted to 0-indexed)
3. **Symbol Storage**: Supports any ASCII characters as input symbols
4. **Error Handling**: Returns false for invalid symbols or undefined transitions

## Extensions and Improvements

Possible enhancements to consider:
1. Support for epsilon (ε) transitions
2. Non-deterministic finite automata (NFA) support
3. Automaton minimization
4. Regular expression to DFA conversion
5. Graphical visualization of the automaton

## Author
Computer Science Student
Date: January 2026
