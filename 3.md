# Lexical Analyzer for C Language Compiler

A comprehensive implementation of a lexical analyzer (scanner) for the C programming language, developed as part of Compiler Design coursework. This tool performs the first phase of compilation by tokenizing C source code and detecting lexical errors.

## üìã Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Requirements](#requirements)
- [Installation](#installation)
- [Usage](#usage)
- [Output Format](#output-format)
- [Test Cases](#test-cases)
- [Technical Details](#technical-details)
- [Project Structure](#project-structure)
- [Limitations](#limitations)
- [Contributing](#contributing)

## üéØ Overview

The lexical analyzer reads C source code files and performs the following tasks:

1. **Tokenization** - Breaks down the input into meaningful tokens
2. **Comment Removal** - Strips out single-line (`//`) and multi-line (`/* */`) comments
3. **Whitespace Handling** - Removes unnecessary whitespace while maintaining line tracking
4. **Symbol Table Management** - Maintains identifiers in a symbol table
5. **Error Detection** - Identifies and reports lexical errors with line/column information

## ‚ú® Features

| Feature | Description |
|---------|-------------|
| **Token Classification** | Categorizes tokens into 6 types: Keywords, Identifiers, Constants, Strings, Punctuation, Operators |
| **C Keyword Recognition** | Recognizes all 32 ANSI C keywords |
| **Multi-line Comments** | Handles both `//` and `/* */` style comments |
| **String & Character Literals** | Properly tokenizes strings (`"..."`) and characters (`'...'`) |
| **Error Reporting** | Detects invalid lexemes like `7H` with precise location |
| **Symbol Table** | Stores all unique identifiers encountered |
| **Operator Support** | Recognizes single and double character operators (`+`, `++`, `==`, etc.) |
| **Line Tracking** | Maintains accurate line and column numbers for error reporting |

## üîß Requirements

- **Compiler**: GCC (GNU Compiler Collection) or any C99-compliant compiler
- **Operating System**: Linux, macOS, Windows (with MinGW/Cygwin)
- **C Standard**: C99 or later

## üì¶ Installation

### Linux/macOS

```bash
# Navigate to the project directory
cd lexical_analyzer_project

# Compile the program
gcc -o lexical_analyzer lexical_analyzer.c -Wall

# Run the program
./lexical_analyzer
```

### Windows (using MinGW)

```cmd
# Navigate to the project directory
cd lexical_analyzer_project

# Compile the program
gcc -o lexical_analyzer.exe lexical_analyzer.c -Wall

# Run the program
lexical_analyzer.exe
```

## üöÄ Usage

### Basic Usage

1. **Start the analyzer**:
   ```bash
   ./lexical_analyzer
   ```

2. **Enter your C source file name** when prompted:
   ```
   Enter the C source file name: test1.c
   ```

3. **View the output** showing:
   - Tokenized output
   - Symbol table entries
   - Lexical errors (if any)

4. **Analyze another file** or exit:
   ```
   Do you want to analyze another file? (y/n): 
   ```

### Example Session

```bash
$ ./lexical_analyzer

==========================================
  LEXICAL ANALYZER
==========================================
  DEBDOOT MANNA 23CS043
==========================================

Enter the C source file name: test1.c

========================================
TOKENS
========================================
Keyword: int
Identifier: main
Punctuation: (
Punctuation: )
Punctuation: {
Keyword: int
Identifier: a
Operator: =
Constant: 5
Punctuation: ,
Error: 7H
...

========================================
SYMBOL TABLE ENTRIES
========================================
1) main
2) a
3) b
========================================

========================================
LEXICAL ERRORS
========================================
7H invalid lexeme
========================================
```

## üìä Output Format

### Tokens

The analyzer categorizes tokens into six types:

| Token Type | Examples |
|------------|----------|
| **Keyword** | `int`, `char`, `return`, `while`, `if` |
| **Identifier** | `main`, `count`, `variable_name` |
| **Constant** | `5`, `3.14`, `0.40` |
| **String** | `"hello"`, `'x'` |
| **Punctuation** | `(`, `)`, `{`, `}`, `;`, `,` |
| **Operator** | `+`, `-`, `*`, `=`, `==`, `++` |

### Symbol Table

Lists all unique identifiers found in the source code:

```
SYMBOL TABLE ENTRIES
1) main
2) a
3) b
```

### Lexical Errors

Reports invalid tokens with their location:

```
LEXICAL ERRORS
7H invalid lexeme
```

## üß™ Test Cases

The project includes three test files:

### test1.c - Basic Error Detection
```c
int main() {
    int a = 5 , 7H;    // Invalid: 7H
    char b = 'x';
    return a + b;
}
```
**Expected**: Detects `7H` as invalid lexeme

### test2.c - Salary Calculation
```c
/* salary calculation */
void main() {
    long int bs, da, hra, gs;
    scanf("%ld", &bs);
    da = bs * 0.40;
    // ... more code
}
```
**Expected**: No errors, multiple identifiers in symbol table

### test3.c - User-Defined Data Types
```c
struct student {
    int id;
    float cgpa;
}
```
**Expected**: Recognizes struct keyword and member identifiers

## üî¨ Technical Details

### Recognized C Keywords (32)

```
auto, break, case, char, const, continue, default, do,
double, else, enum, extern, float, for, goto, if,
int, long, register, return, short, signed, sizeof, static,
struct, switch, typedef, union, unsigned, void, volatile, while
```

### Supported Operators

**Single Character**: `+`, `-`, `*`, `/`, `%`, `=`, `<`, `>`, `!`, `&`, `|`, `^`, `~`

**Double Character**: `==`, `!=`, `<=`, `>=`, `&&`, `||`, `++`, `--`, `+=`, `-=`, `*=`, `/=`, `%=`, `->`, `<<`, `>>`

### Token Recognition Algorithm

The analyzer uses a finite automaton approach:

1. **Skip whitespace** and track line/column numbers
2. **Identify token type** based on first character:
   - Letter/underscore ‚Üí Identifier or Keyword
   - Digit ‚Üí Constant (with error checking for invalid formats)
   - Quote ‚Üí String literal
   - Operator character ‚Üí Operator (check for 2-char operators)
   - Punctuation ‚Üí Punctuation token
3. **Build complete token** by reading ahead
4. **Classify and store** in appropriate category

### Error Detection

The analyzer detects:

- **Invalid numeric literals**: Numbers followed by letters (e.g., `7H`, `123abc`)
- **Invalid characters**: Characters not part of C syntax
- **Malformed tokens**: Incomplete string literals, etc.

## üìÅ Project Structure

```
lexical_analyzer_project/
‚îÇ
‚îú‚îÄ‚îÄ lexical_analyzer.c    # Main source code
‚îú‚îÄ‚îÄ README.md             # This documentation
‚îú‚îÄ‚îÄ test1.c               # Test case 1 (with error)
‚îú‚îÄ‚îÄ test2.c               # Test case 2 (salary calculation)
‚îî‚îÄ‚îÄ test3.c               # Test case 3 (struct example)
```

## ‚ö†Ô∏è Limitations

1. **Preprocessor Directives**: Does not process `#include`, `#define`, etc.
2. **Escape Sequences**: Basic support; complex escape sequences may not be fully validated
3. **Number Formats**: Does not support hexadecimal (`0x`), octal (`0`), or scientific notation
4. **Token Length**: Maximum token length is 100 characters
5. **Symbol Table Size**: Limited to 1000 unique identifiers
6. **Unicode**: Does not support Unicode identifiers

## üîÑ Future Enhancements

- [ ] Add support for preprocessor directives
- [ ] Implement hexadecimal and octal number recognition
- [ ] Add scientific notation support for floating-point numbers
- [ ] Enhanced error recovery mechanisms
- [ ] Output to file option
- [ ] Support for C++ keywords and syntax
- [ ] Graphical user interface (GUI)
- [ ] Integration with parser (syntax analyzer)

## üìö Learning Objectives

This project demonstrates understanding of:

- Lexical analysis in compiler design
- Finite automata and state machines
- Token recognition algorithms
- Symbol table management
- Error detection and reporting
- File I/O operations in C
- Modular programming practices

## ü§ù Contributing

This is an academic project, but suggestions for improvements are welcome:

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Test thoroughly with various C programs
5. Submit a pull request

## üìù Assignment Specification

**Objective**: Design and implement a lexical analyzer for C programming language

**Input**: C source code file containing keywords, identifiers, constants, strings, punctuation, operators, comments, and whitespace

**Output**:
- Tokenized output categorizing tokens into six types
- Symbol table with all identified identifiers
- Detection and reporting of lexical errors
- Modified source code (comments and whitespace removed)

**Language Constraint**: Can be implemented in any programming language (implemented in C)

## üìñ References

- Compilers: Principles, Techniques, and Tools (Dragon Book) - Aho, Lam, Sethi, Ullman
- Modern Compiler Implementation in C - Andrew W. Appel
- ANSI C Standard (ISO/IEC 9899)

## üë®‚Äçüíª Author

Created as part of Compiler Design Laboratory coursework

## üìÑ License

This project is created for educational purposes. Feel free to use and modify for learning.

---

**Note**: This lexical analyzer is designed for educational purposes to understand the first phase of compilation. For production use, consider established tools like Flex/Lex.

## üéì Compilation Commands Reference

```bash
# Basic compilation
gcc lexical_analyzer.c -o lexical_analyzer

# With all warnings
gcc -Wall lexical_analyzer.c -o lexical_analyzer

# With optimization
gcc -O2 lexical_analyzer.c -o lexical_analyzer

# Debug mode
gcc -g lexical_analyzer.c -o lexical_analyzer
```

## üêõ Troubleshooting

### Common Issues

**Issue**: "Cannot open file"
- **Solution**: Ensure the file exists in the same directory as the executable or provide the full path

**Issue**: "Permission denied"
- **Solution**: Make the executable file executable: `chmod +x lexical_analyzer`

**Issue**: Compilation errors
- **Solution**: Ensure you have GCC installed: `gcc --version`

---

**Last Updated**: January 2026  
**Version**: 1.0  
**Status**: Tested and Working ‚úÖ
